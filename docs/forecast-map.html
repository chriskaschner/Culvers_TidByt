<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flavor Fronts — Weather Map Forecast</title>
  <meta name="description" content="Weather-map style flavor forecast. See where your favorite custard flavors are strongest across nearby stores over the next 7 days.">
  <meta property="og:title" content="Flavor Fronts — Weather Map Forecast">
  <meta property="og:description" content="Track flavor fronts and forecast strength by store over the next 7 days.">
  <meta property="og:url" content="https://custard.chriskaschner.com/forecast-map.html">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-map.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha384-sHL9NAb7lN7rfvG5lfHpm643Xkcjzp4jFvuavGOndn6pjVqS6ny56CAt3nsEVT4H" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha384-cxOPjt7s7Iz04uaHJceBmS+qpjv2JkIHNVcuOrM+YHwZOmJGBXI00mdUXEq65HTH" crossorigin=""></script>
</head>
<body>
  <header class="forecast-header">
    <h1 style="color:#003366;font-size:1.5rem;">Flavor Fronts</h1>
    <p style="color:#666;margin-top:0.25rem;font-size:0.875rem;">Weather-map style flavor movement across nearby stores</p>
    <nav class="nav-links" style="margin-top:0.75rem;">
      <a href="index.html">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html">Map</a>
      <a href="radar.html">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
      <a href="forecast-map.html" class="nav-active">Fronts</a>
    </nav>
  </header>

  <main>
    <section class="panel fronts-controls">
      <div class="fronts-control-grid">
        <div class="fronts-control-block">
          <label for="fronts-location">Location</label>
          <div class="location-row">
            <input id="fronts-location" type="text" placeholder="City, state or ZIP">
            <button id="fronts-geo" class="icon-btn" title="Use my location" aria-label="Use my location">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"></path>
              </svg>
            </button>
            <button id="fronts-refresh" class="btn-search">Load Fronts</button>
          </div>
        </div>

        <div class="fronts-control-block">
          <label for="fronts-day">Forecast Day</label>
          <div class="fronts-day-wrap">
            <input id="fronts-day" type="range" min="0" max="6" step="1" value="0">
            <span id="fronts-day-label" class="fronts-day-label">Today</span>
          </div>
        </div>

        <div class="fronts-control-block">
          <label for="fronts-flavor">Flavor Front</label>
          <select id="fronts-flavor">
            <option value="">Load a location first...</option>
          </select>
        </div>
      </div>

      <div id="fronts-status" class="fronts-status">Select a location to build your local forecast map.</div>
    </section>

    <section class="fronts-layout">
      <div class="fronts-map-shell">
        <div id="fronts-map"></div>
        <div class="fronts-legend" aria-label="Map legend">
          <span><i class="legend-dot legend-confirmed"></i> Confirmed today</span>
          <span><i class="legend-dot legend-high"></i> High forecast</span>
          <span><i class="legend-dot legend-medium"></i> Medium forecast</span>
          <span><i class="legend-dot legend-low"></i> Low forecast</span>
        </div>
      </div>

      <aside class="panel fronts-side">
        <h2>Front Summary</h2>
        <div class="fronts-metrics">
          <div class="fronts-metric">
            <span class="fronts-metric-label">Stores loaded</span>
            <strong id="metric-stores">0</strong>
          </div>
          <div class="fronts-metric">
            <span class="fronts-metric-label">Active front zones</span>
            <strong id="metric-active">0</strong>
          </div>
          <div class="fronts-metric">
            <span class="fronts-metric-label">Strongest signal</span>
            <strong id="metric-peak">-</strong>
          </div>
        </div>

        <h3>Top Hotspots</h3>
        <ul id="fronts-hotspots" class="fronts-hotspots">
          <li>Load a location to see hotspots.</li>
        </ul>

        <h3>How to Read This</h3>
        <p class="fronts-note">Each marker is a nearby store. Bigger and warmer markers mean a stronger chance of the selected flavor on the selected day.</p>
        <p class="fronts-note">Today uses confirmed flavor data. Future days use model forecast probabilities.</p>
      </aside>
    </section>
  </main>

  <footer>
    <div class="footer-brands">Culver's forecast coverage with 7-day model outlook.</div>
    <p style="margin-top:0.5rem;">Not affiliated with any restaurant. Forecasts are probabilistic and can change.</p>
  </footer>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';

    const frontsLocationInput = document.getElementById('fronts-location');
    const frontsGeoBtn = document.getElementById('fronts-geo');
    const frontsRefreshBtn = document.getElementById('fronts-refresh');
    const frontsDayInput = document.getElementById('fronts-day');
    const frontsDayLabel = document.getElementById('fronts-day-label');
    const frontsFlavorSelect = document.getElementById('fronts-flavor');
    const frontsStatus = document.getElementById('fronts-status');

    const metricStores = document.getElementById('metric-stores');
    const metricActive = document.getElementById('metric-active');
    const metricPeak = document.getElementById('metric-peak');
    const frontsHotspots = document.getElementById('fronts-hotspots');

    const map = L.map('fronts-map').setView([43.0, -89.5], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    const baseLayer = L.layerGroup().addTo(map);
    const signalLayer = L.layerGroup().addTo(map);

    let nearbyStores = [];
    const forecastCache = new Map();
    let selectedFlavorKey = '';

    function toISODate(dateObj) {
      return dateObj.toISOString().slice(0, 10);
    }

    function addDays(dateObj, days) {
      const out = new Date(dateObj);
      out.setDate(out.getDate() + days);
      return out;
    }

    function normalizeFlavor(name) {
      if (!name) return '';
      return String(name)
        .toLowerCase()
        .replace(/[\u00ae\u2122]/g, '')
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/\s+/g, ' ')
        .trim();
    }

    function escapeHtml(text) {
      if (!text) return '';
      return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function currentDateAtNoon() {
      const now = new Date();
      now.setHours(12, 0, 0, 0);
      return now;
    }

    function activeDateFromSlider() {
      const dayOffset = Number(frontsDayInput.value || 0);
      return addDays(currentDateAtNoon(), dayOffset);
    }

    function formatDayLabel(dayOffset, activeDate) {
      if (dayOffset === 0) return 'Today';
      if (dayOffset === 1) return 'Tomorrow';
      return activeDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
    }

    function updateDayLabel() {
      const dayOffset = Number(frontsDayInput.value || 0);
      const activeDate = activeDateFromSlider();
      frontsDayLabel.textContent = formatDayLabel(dayOffset, activeDate);
    }

    function setStatus(message, tone) {
      frontsStatus.textContent = message;
      frontsStatus.className = 'fronts-status';
      if (tone === 'error') frontsStatus.classList.add('fronts-status-error');
      if (tone === 'loading') frontsStatus.classList.add('fronts-status-loading');
      if (tone === 'success') frontsStatus.classList.add('fronts-status-success');
    }

    function flavorMapForDay(dayIso, dayOffset) {
      const scoreMap = new Map();

      function addScore(flavorName, score) {
        const key = normalizeFlavor(flavorName);
        if (!key || !score || score <= 0) return;
        const prior = scoreMap.get(key) || { name: flavorName, score: 0 };
        prior.score += score;
        // Keep the longest / most descriptive display name we've seen
        if ((flavorName || '').length > (prior.name || '').length) prior.name = flavorName;
        scoreMap.set(key, prior);
      }

      for (const store of nearbyStores) {
        if (dayOffset === 0 && store.flavor) {
          addScore(store.flavor, 1);
        }

        const forecast = forecastCache.get(store.slug);
        if (!forecast || !Array.isArray(forecast.days)) continue;
        const day = forecast.days.find((d) => d.date === dayIso);
        if (!day || !Array.isArray(day.predictions)) continue;

        for (const prediction of day.predictions.slice(0, 4)) {
          const probability = Number(prediction.probability || 0);
          if (probability > 0) addScore(prediction.flavor, probability);
        }
      }

      return [...scoreMap.entries()]
        .map(([key, v]) => ({ key, name: v.name, score: v.score }))
        .sort((a, b) => b.score - a.score);
    }

    function populateFlavorSelect() {
      const dayOffset = Number(frontsDayInput.value || 0);
      const dayIso = toISODate(activeDateFromSlider());
      const topFlavors = flavorMapForDay(dayIso, dayOffset).slice(0, 14);

      frontsFlavorSelect.innerHTML = '';
      if (topFlavors.length === 0) {
        frontsFlavorSelect.innerHTML = '<option value="">No forecast flavors available</option>';
        frontsFlavorSelect.disabled = true;
        selectedFlavorKey = '';
        return;
      }

      frontsFlavorSelect.disabled = false;
      const hasPrevious = topFlavors.some((f) => f.key === selectedFlavorKey);
      if (!hasPrevious) selectedFlavorKey = topFlavors[0].key;

      for (const flavor of topFlavors) {
        const option = document.createElement('option');
        option.value = flavor.key;
        option.textContent = flavor.name + ' (' + flavor.score.toFixed(1) + ')';
        if (flavor.key === selectedFlavorKey) option.selected = true;
        frontsFlavorSelect.appendChild(option);
      }
    }

    function signalForStore(store, dayIso, dayOffset, flavorKey) {
      if (!flavorKey) return null;

      if (dayOffset === 0 && normalizeFlavor(store.flavor) === flavorKey) {
        return {
          score: 1,
          mode: 'confirmed',
          detail: 'Confirmed today',
        };
      }

      const forecast = forecastCache.get(store.slug);
      if (!forecast || !Array.isArray(forecast.days)) return null;

      const day = forecast.days.find((d) => d.date === dayIso);
      if (!day || !Array.isArray(day.predictions)) return null;

      const prediction = day.predictions.find((p) => normalizeFlavor(p.flavor) === flavorKey);
      if (!prediction) return null;

      const score = Number(prediction.probability || 0);
      if (score <= 0) return null;

      return {
        score,
        mode: 'predicted',
        detail: Math.round(score * 100) + '% forecast',
      };
    }

    function signalColor(signal) {
      if (!signal) return '#94a3b8';
      if (signal.mode === 'confirmed') return '#005696';
      if (signal.score >= 0.18) return '#dc2626';
      if (signal.score >= 0.12) return '#f97316';
      if (signal.score >= 0.08) return '#f59e0b';
      if (signal.score >= 0.05) return '#65a30d';
      return '#0ea5e9';
    }

    function signalRadius(signal) {
      if (!signal) return 3;
      return Math.min(20, 6 + signal.score * 30);
    }

    function renderMapSignals() {
      baseLayer.clearLayers();
      signalLayer.clearLayers();

      const dayOffset = Number(frontsDayInput.value || 0);
      const dayIso = toISODate(activeDateFromSlider());
      const flavorKey = frontsFlavorSelect.value;
      selectedFlavorKey = flavorKey;

      let activeCount = 0;
      const hotspots = [];

      for (const store of nearbyStores) {
        if (!store.lat || !store.lon) continue;

        // Base point so the region stays readable even when no signal is active.
        L.circleMarker([store.lat, store.lon], {
          radius: 3,
          color: '#e2e8f0',
          weight: 1,
          fillColor: '#cbd5e1',
          fillOpacity: 0.45,
        }).addTo(baseLayer);

        const signal = signalForStore(store, dayIso, dayOffset, flavorKey);
        if (!signal || signal.score < 0.03) continue;

        activeCount += 1;
        hotspots.push({ store, signal });

        const marker = L.circleMarker([store.lat, store.lon], {
          radius: signalRadius(signal),
          color: '#ffffff',
          weight: 1.5,
          fillColor: signalColor(signal),
          fillOpacity: Math.min(0.95, 0.35 + signal.score),
        });

        const todayFlavorLine = store.flavor ? '<div><strong>Today:</strong> ' + escapeHtml(store.flavor) + '</div>' : '';
        const popup = '<div class="fronts-popup">'
          + '<div><strong>' + escapeHtml(store.name || store.slug) + '</strong></div>'
          + '<div>' + escapeHtml(store.address || '') + '</div>'
          + todayFlavorLine
          + '<div><strong>Signal:</strong> ' + escapeHtml(signal.detail) + '</div>'
          + '</div>';

        marker.bindPopup(popup);
        marker.addTo(signalLayer);
      }

      hotspots.sort((a, b) => b.signal.score - a.signal.score);
      renderHotspots(hotspots.slice(0, 8));

      metricStores.textContent = String(nearbyStores.length);
      metricActive.textContent = String(activeCount);
      if (hotspots.length > 0) {
        const peak = hotspots[0];
        metricPeak.textContent = Math.round(peak.signal.score * 100) + '%';
      } else {
        metricPeak.textContent = '-';
      }
    }

    function renderHotspots(entries) {
      frontsHotspots.innerHTML = '';
      if (!entries.length) {
        frontsHotspots.innerHTML = '<li>No strong front zones for this flavor/day yet.</li>';
        return;
      }

      for (const entry of entries) {
        const li = document.createElement('li');
        const pct = Math.round(entry.signal.score * 100);
        li.innerHTML = '<span>' + escapeHtml(entry.store.name || entry.store.slug) + '</span>'
          + '<span class="fronts-hotspot-score">' + pct + '%</span>';
        frontsHotspots.appendChild(li);
      }
    }

    async function fetchNearbyStores(locationText) {
      const url = WORKER_BASE + '/api/v1/nearby-flavors?location=' + encodeURIComponent(locationText) + '&limit=40';
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error('Unable to load nearby stores (' + resp.status + ')');
      }
      const data = await resp.json();
      const stores = (data.nearby || []).filter((store) => store.lat && store.lon && store.slug);
      return stores;
    }

    async function fetchForecastForSlug(slug) {
      if (forecastCache.has(slug)) return forecastCache.get(slug);

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/forecast/' + encodeURIComponent(slug));
        if (!resp.ok) {
          forecastCache.set(slug, null);
          return null;
        }
        const payload = await resp.json();
        forecastCache.set(slug, payload);
        return payload;
      } catch {
        forecastCache.set(slug, null);
        return null;
      }
    }

    async function warmForecasts(stores) {
      await Promise.all(stores.map((store) => fetchForecastForSlug(store.slug)));
    }

    function fitMapToStores(stores) {
      const bounds = L.latLngBounds();
      for (const store of stores) {
        bounds.extend([store.lat, store.lon]);
      }
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [35, 35], maxZoom: 11 });
      }
    }

    async function reverseGeocode(lat, lon) {
      try {
        const resp = await fetch('https://nominatim.openstreetmap.org/reverse?lat=' + lat + '&lon=' + lon + '&format=json&zoom=10');
        const data = await resp.json();
        const address = data.address || {};
        const city = address.city || address.town || address.village || address.county || '';
        const state = address.state || '';
        if (city && state) return city + ', ' + state;
      } catch {
        // Fall through to null.
      }
      return null;
    }

    async function useDetectedLocation() {
      frontsGeoBtn.disabled = true;
      try {
        if (navigator.geolocation) {
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
          });
          const label = await reverseGeocode(pos.coords.latitude, pos.coords.longitude);
          if (label) {
            frontsLocationInput.value = label;
            frontsGeoBtn.disabled = false;
            await loadFronts();
            return;
          }
        }
      } catch {
        // Fall back to CF geolocation.
      }

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
        const geo = await resp.json();
        if (geo.city && geo.state) {
          frontsLocationInput.value = geo.city + ', ' + geo.state;
          await loadFronts();
        } else {
          setStatus('Unable to determine location. Enter a city or ZIP.', 'error');
        }
      } catch {
        setStatus('Unable to determine location. Enter a city or ZIP.', 'error');
      }

      frontsGeoBtn.disabled = false;
    }

    async function loadFronts() {
      const locationText = frontsLocationInput.value.trim();
      if (!locationText) {
        setStatus('Enter a location first (for example: Madison, WI).', 'error');
        frontsLocationInput.focus();
        return;
      }

      setStatus('Loading nearby stores and forecast fronts...', 'loading');
      frontsRefreshBtn.disabled = true;

      try {
        const stores = await fetchNearbyStores(locationText);
        if (!stores.length) {
          nearbyStores = [];
          baseLayer.clearLayers();
          signalLayer.clearLayers();
          metricStores.textContent = '0';
          metricActive.textContent = '0';
          metricPeak.textContent = '-';
          frontsHotspots.innerHTML = '<li>No stores returned for this location.</li>';
          frontsFlavorSelect.innerHTML = '<option value="">No stores found</option>';
          frontsFlavorSelect.disabled = true;
          setStatus('No nearby stores found. Try a different city or ZIP.', 'error');
          return;
        }

        nearbyStores = stores;
        fitMapToStores(nearbyStores);
        await warmForecasts(nearbyStores);

        updateDayLabel();
        populateFlavorSelect();
        renderMapSignals();

        const dayOffset = Number(frontsDayInput.value || 0);
        const dayText = dayOffset === 0 ? 'today' : 'day ' + dayOffset;
        setStatus('Loaded ' + nearbyStores.length + ' stores. Showing fronts for ' + dayText + '.', 'success');
      } catch (err) {
        setStatus(err.message || 'Failed to load fronts.', 'error');
      } finally {
        frontsRefreshBtn.disabled = false;
      }
    }

    frontsRefreshBtn.addEventListener('click', loadFronts);
    frontsLocationInput.addEventListener('keydown', (evt) => {
      if (evt.key === 'Enter') loadFronts();
    });

    frontsGeoBtn.addEventListener('click', useDetectedLocation);

    frontsDayInput.addEventListener('input', () => {
      updateDayLabel();
      populateFlavorSelect();
      renderMapSignals();
    });

    frontsFlavorSelect.addEventListener('change', () => {
      selectedFlavorKey = frontsFlavorSelect.value;
      renderMapSignals();
    });

    async function init() {
      updateDayLabel();

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
        if (resp.ok) {
          const geo = await resp.json();
          if (geo.city && geo.state) {
            frontsLocationInput.value = geo.city + ', ' + geo.state;
            await loadFronts();
            return;
          }
        }
      } catch {
        // No-op: user can type location manually.
      }

      setStatus('Select a location to build your local forecast map.', 'success');
    }

    init();
  </script>
</body>
</html>
